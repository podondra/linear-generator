<h1>linearni generatory</h1>

<p><a href="&#x6D;&#97;&#105;l&#x74;o:&#112;o&#100;&#x73;&#122;o&#x6E;&#100;&#64;&#x66;&#105;&#x74;&#x2E;&#99;v&#117;&#x74;&#x2E;&#x63;&#122;">&#112;o&#100;&#x73;&#122;o&#x6E;&#100;&#64;&#x66;&#105;&#x74;&#x2E;&#99;v&#117;&#x74;&#x2E;&#x63;&#122;</a></p>

<h2>kapitola 1</h2>

<h3>definice problemu</h3>

<p>Mějme několik (<code>G</code>, pozor může to být i číslo v řádech miliónů!) daných
lineárních generátorů, každý z nich je dán parametry <code>a</code>, <code>b</code>, <code>n</code>. Generátor
vypočítává posloupnost <code>x[i] = (a * x[i - 1] + b) mod 2 ^ n</code>, kde <code>a</code> a <code>b</code>
jsou kladná lichá čísla, <code>10 &lt; n &lt; 32</code> a <code>x[0] = 0</code>. Počet členů této
posloupnosti je <code>k</code> (pro všechny generátory stejné). Úkolem je pro dané
konstanty <code>c</code>, <code>d</code>, <code>e</code> (pro všechny generátory stejné), najít:</p>

<ol>
<li>kolikrát je pro daný generátor <code>x[i]</code> v intervalu <code>[c, d]</code></li>
<li>kolik je pro daný generátor minimální a maximální Hammingova vzdálenost
mezi <code>x[i]</code> a parametrem <code>e</code></li>
</ol>

<h3>popis sekvencniho algoritmu a jeho implementace</h3>

<p>Sekvenci algoritmus se sklada ze dvou <code>for</code> cyklu. Vnejsi cyklus iteruje
pres vsechny linearni generatory <code>G</code>. <code>G</code> jsou ulozeny ve
dvourozmernem poli. V kazdem radku je trojice <code>uint32_t</code> cisel <code>a</code>, <code>b</code> a
<code>n</code>.</p>

<pre><code>/* for each linear generator */
for (size_t i = 0; i &lt; num; ++i) {
    a = linear_generators[i][0];
    b = linear_generators[i][1];
    n = linear_generators[i][2];
    x = 0;
    count = 0;
    min = UINT32_MAX;
    max = 0;
</code></pre>

<p>Vnitrni cyklus pocita a zkouma jednotlive cleny posloupnosti <code>x[k]</code>
linearniho generatoru.</p>

<pre><code>    for (size_t j = 0; j &lt; k; ++j) {
        /* compute next value */
        x = lin_gen(a, x, b, n);

        /* check if x is in interval */
        if (is_in_interval(x, c, d))
            ++count;

        /* compute hamming distance */
        dist = hamming_distance(x, e);
        /* check minimal hamming distance */
        if (min &gt; dist)
            min = dist;
        /* check maximal hamming distance */
        if (max &lt; dist)
            max = dist;
    }

    /* use computed values so compiler does not exclude them */
    fprintf(stderr, "%" PRIu32 "%" PRIu32 "%" PRIu32, count, min, max);
}
</code></pre>

<h4>popis implementovanych funkci</h4>

<ol>
<li><p><code>lin_gen()</code> pocita nasledujici clen posloupnosti. Pro umocneni
<code>2 ^ n</code> pouzivam operaci bitovy posun.</p>

<pre><code>uint32_t lin_gen(uint32_t a, uint32_t x, uint32_t b, uint32_t n) {
    /* don't care about overflow */
    return (a * x + b) % (2 &lt;&lt; (n - 1));
}
</code></pre></li>
<li><p><code>is_in_interval()</code> provede dve porovnani a vrati <code>true</code>
pokud je <code>x</code> v zadanem intervalu jinak <code>false</code>.</p>

<pre><code>bool is_in_interval(uint32_t x, uint32_t start, uint32_t end) {
    return start &lt;= x &amp;&amp; x &lt;= end;
}
</code></pre></li>
<li><p><code>hamming_distance()</code> implementuje algoritmus pro ziskani
Hammingovy vzdalenosti z bitoveho or (<code>^</code>) promennych <code>x</code> a <code>e</code>
postupnym odebiranim bitu ve <code>while</code> cyklu. Tato implementace je datove
zavisla. Presto budu generovat data nahodne. Po optimalizacich bude
tato zavislost odstarnena.</p>

<pre><code>uint32_t hamming_distance(uint32_t x, uint32_t y) {
    uint32_t distance = 0;
    uint32_t xor_val = x ^ y;
    while (xor_val) { /* count the number of bits set */
        ++distance; /* a bit is set increment the counter */
        xor_val &amp;= xor_val - 1; /* remove the counted bit */
    }
    return distance;
}
</code></pre></li>
</ol>

<h3>kompilace programu</h3>

<p>Pro kompilaci programu pouzivam kompilator gcc. Zakladni kompilace pouziva
nasleduji prepinace:</p>

<pre><code>g++ -std=c++11 -march=ivybridge -O3 ...
</code></pre>

<p><code>-march=ivybridge</code> zajisti kompilovani kodu pro vypocetni svazky Intel Xeon
2620 v2 @ 2.1Ghz. Toto nastaveni jsem zjistil prikazem:</p>

<pre><code>gcc -march=native -Q --help=target | grep march
  -march=                           ivybridge
</code></pre>

<h3>namerene hodnoty casove slozitost</h3>

<p><img src="img/seq.svg" alt="casova slozitost sekvencni implementace" title="" /></p>

<h2>kapitola 2 (optimalizovana verze)</h2>

<h3>popis úprav programu a jejich implementace</h3>

<p>V nasledujici casti popisu jednotlive optimalizece programu a analyzuji jejich
dopad na vykonost vypoctu.</p>

<h4>inline funkce a population count</h4>

<p>Vlozenim kodu funkci v tuto chvili neziskam zadne zrychleni, protoze <code>-O3</code>
nastaveni kompilatoru toto provede automaticky.</p>

<p>Kod pro vypocet Hammingovy vzdalenosti je neefektvni, protoze pouziva
<code>while</code> loop a netrva tedy konstatni dobu. Efektivnejsi implementace je
pomoci <code>population count</code>:</p>

<pre><code>dist = x ^ e;
dist = dist - ((dist &gt;&gt; 1) &amp; 0x55555555);
dist = (dist &amp; 0x33333333) + ((dist &gt;&gt; 2) &amp; 0x33333333);
dist = (((dist + (dist &gt;&gt; 4)) &amp; 0x0F0F0F0F) * 0x01010101) &gt;&gt; 24;
</code></pre>

<p>Tento algoritmus vypocita Hammingovu vzdalenost 32 bitoveho integeru
(<code>uint32_t</code>) v konstantnim case. Tato optimalizace program zrychli v prumeru
ctryrikrat.</p>

<p><img src="img/opt-popcount.svg" alt="population count" title="" /></p>

<p><img src="img/opt-popcount-per-s.svg" alt="population count - per second" title="" /></p>

<h4>loop intechange</h4>

<p>Program nevyuziva vektorovych instrukci AVX procesoru. Podporu tech instrukci
pri kompilaci zapneme prepinacem <code>-mavx</code>. Vyuzite vektorovych instrukci je
pro zrychleni zasadni. Kompilator instrukce nevyuziva kvuli datove zavislosti
<code>x</code> na predchozi hodnote ve vnitrim cyklu:</p>

<pre><code>x = ((a * x + b) % (2 &lt;&lt; (n - 1)));
</code></pre>

<p>Transformace loop interchange odstrani tuto zavislost. Vnejsi cyklus bude
iterovat pres jednotlive cleny posloupnosti <code>x[i]</code> a cyklus vnitri pres vsechny
linearni generatory. Bohuzel se pro nektere zhorsi vyuziti cache
pameti, protoze se parametry linearnich generatoru budou opakovane nacitat.</p>

<p><img src="img/opt-interchange.svg" alt="loop interchange" title="" /></p>

<p>Vysledny kod vypada takto (parametry linernich generatu ukladam v
jednorozmernych polich):</p>

<pre><code>for (size_t i = 0; i &lt; k; ++i) {
    /* for each linear generator */
    for (size_t j = 0; j &lt; num; ++j) {
        /* compute next value */
        x[j] = ((a[j] * x[j] + b[j]) % (2 &lt;&lt; (n[j] - 1)));

        /* check if x is in interval */
        if (c &lt;= x[j] &amp;&amp; x[j] &lt;= d)
            count[j] += 1;

        /* compute hamming distance */
        dist = x[j] ^ e;
        dist = dist - ((dist &gt;&gt; 1) &amp; 0x55555555);
        dist = (dist &amp; 0x33333333) + ((dist &gt;&gt; 2) &amp; 0x33333333);
        dist = (((dist + (dist &gt;&gt; 4)) &amp; 0x0F0F0F0F) * 0x01010101) &gt;&gt; 24;

        /* check minimal hamming distance */
        if (min[j] &gt; dist)
            min[j] = dist;
        /* check maximal hamming distance */
        if (max[j] &lt; dist)
            max[j] = dist;
    }
}
</code></pre>

<p>Kompilator samozrejme tento kod nedokaze vektorizovat. Vypis prepinace
<code>-fopt-info-vec-all</code> gcc:</p>

<pre><code>not vectorized: control flow in loop.
</code></pre>

<h4>branch-less code</h4>

<p>To znamena ze musime odstranit <code>if</code> podminky z vnitrniho cyklu. Misto nich lze
pouzit ternarni operatory:</p>

<pre><code>count[j] += (c &lt;= x[j] &amp;&amp; x[j] &lt;= d) ? 1 : 0;
min[j] = (min[j] &lt; dist) ? min[j] : dist;
max[j] = (max[j] &gt; dist) ? max[j] : dist;
</code></pre>

<p>Nyni kompilator hlasi problemy s aliasingem:</p>

<pre><code>number of versioning for alias run-time tests exceeds 10
</code></pre>

<p>Upravim kod pridanim klicovych slov <code>__restrict__</code>, ktere aliasing vylouci. Pro
snadnejsi implementaci vytvorim pro vypocet vlastni funkci <code>opt_computation()</code>:</p>

<pre><code>void opt_computation(
        uint32_t num,
        uint32_t k,
        uint32_t c,
        uint32_t d,
        uint32_t e,
        uint32_t *__restrict__ a,
        uint32_t *__restrict__ b,
        uint32_t *__restrict__ n,
        uint32_t *__restrict__ x,
        uint32_t *__restrict__ min,
        uint32_t *__restrict__ max,
        uint32_t *__restrict__ count
        );
</code></pre>

<p>Kompilator stale nemuze tento program vektorizovat. Nyni hlasi nepodporovanou
operaci:</p>

<pre><code>not vectorized: relevant stmt not supported: _30 = 2 &lt;&lt; _29;
</code></pre>

<h4>loop fission</h4>

<p>Je treba se teto operace zbavit. To v tomto pripade lze pomoci transformace
loop fision. Zbytecne stale dokola pocitam hodnotu <code>2 ^ n</code>, ktera se v
prubehu vypoctu nemeni. Vypocitam ji tedy pre telem hlavnich <code>for</code> cyklu:</p>

<pre><code>for (size_t j = 0; j &lt; num; ++j)
    n[j] = 2 &lt;&lt; (n[j] - 1);

for (size_t i = 0; i &lt; k; ++i) {
    for (size_t j = 0; j &lt; num; ++j) {
        x[j] = (a[j] * x[j] + b[j]) % n[j];
</code></pre>

<p>todo zpomaleni</p>

<h4>vektorizace</h4>

<p>AVX bohuzel nepodporuje modulo operator:</p>

<pre><code>not vectorized: relevant stmt not supported: _40 = _37 % _39;
</code></pre>

<p>Modulo lze nahradit nasobenim inverze cisla. Abych mohl tuto optimalizaci
provest musim pole <code>n</code> prevest z datoveho typu <code>uint32_t</code> na typ <code>float</code>.</p>

<h4>memory alignment</h4>

<pre><code>loop peeled for vectorization to enhance alignment
</code></pre>
